name: Verify Repair Results

on:
  schedule:
    # Run every 40 minutes
    - cron: '*/40 * * * *'
  workflow_dispatch:
    inputs:
      triggered_by:
        description: 'What triggered this verification'
        required: false
        default: 'manual'
        type: string
      iteration:
        description: 'Loop iteration to verify'
        required: false
        type: string
      check_last_hours:
        description: 'Check workflows from last N hours'
        required: false
        default: '2'
        type: string

env:
  GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
  CHECK_HOURS: ${{ inputs.check_last_hours || '2' }}

jobs:
  verify-repairs:
    name: Verify Repair Success
    runs-on: ubuntu-latest
    outputs:
      remaining_failures: ${{ steps.check.outputs.remaining_failures }}
      repair_success_rate: ${{ steps.analyze.outputs.repair_success_rate }}
      should_continue_loop: ${{ steps.analyze.outputs.should_continue_loop }}
    
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          token: ${{ secrets.GITHUB_TOKEN }}
          fetch-depth: 1

      - name: Setup GitHub CLI
        run: |
          gh --version
          gh auth status

      - name: Load repair state
        id: load_state
        run: |
          # Load repair history if it exists
          if [[ -f .github/repair-state/repair-history.json ]]; then
            TOTAL_REPAIRS=$(jq -r '.total_repairs // 0' .github/repair-state/repair-history.json)
            SUCCESS_RATE=$(jq -r '.success_rate // 0' .github/repair-state/repair-history.json)
          else
            TOTAL_REPAIRS=0
            SUCCESS_RATE=0
          fi
          
          # Load loop state
          if [[ -f .github/repair-state/loop-state.json ]]; then
            CURRENT_ITERATION=$(jq -r '.iteration // 0' .github/repair-state/loop-state.json)
          else
            CURRENT_ITERATION=0
          fi
          
          echo "total_repairs=$TOTAL_REPAIRS" >> $GITHUB_OUTPUT
          echo "success_rate=$SUCCESS_RATE" >> $GITHUB_OUTPUT
          echo "current_iteration=$CURRENT_ITERATION" >> $GITHUB_OUTPUT

      - name: Check for remaining failures
        id: check
        run: |
          echo "Checking for remaining workflow failures..."
          
          # Get current time and time CHECK_HOURS ago
          CURRENT_TIME=$(date -u +%Y-%m-%dT%H:%M:%SZ)
          CHECK_FROM=$(date -u -d "$CHECK_HOURS hours ago" +%Y-%m-%dT%H:%M:%SZ)
          
          echo "Checking workflows since: $CHECK_FROM"
          
          # Get failed workflows from the specified time period
          FAILED_RUNS=$(gh run list \
            --status failure \
            --limit 20 \
            --json databaseId,workflowName,headBranch,conclusion,createdAt,updatedAt \
            --jq --arg since "$CHECK_FROM" \
            '[.[] | select(.conclusion == "failure" and .updatedAt >= $since)]')
          
          # Count failures
          FAILURE_COUNT=$(echo "$FAILED_RUNS" | jq 'length')
          
          echo "remaining_failures=$FAILURE_COUNT" >> $GITHUB_OUTPUT
          echo "failed_runs<<EOF" >> $GITHUB_OUTPUT
          echo "$FAILED_RUNS" >> $GITHUB_OUTPUT
          echo "EOF" >> $GITHUB_OUTPUT
          
          echo "Found $FAILURE_COUNT remaining failures"
          
          # Display failed workflows
          if [[ $FAILURE_COUNT -gt 0 ]]; then
            echo "Remaining failed workflows:"
            echo "$FAILED_RUNS" | jq -r '.[] | "- \(.workflowName) (ID: \(.databaseId), Updated: \(.updatedAt))"'
          fi

      - name: Analyze repair effectiveness
        id: analyze
        run: |
          REMAINING_FAILURES=${{ steps.check.outputs.remaining_failures }}
          CURRENT_ITERATION=${{ steps.load_state.outputs.current_iteration }}
          SUCCESS_RATE=${{ steps.load_state.outputs.success_rate }}
          
          echo "=== Repair Analysis ==="
          echo "Current iteration: $CURRENT_ITERATION"
          echo "Remaining failures: $REMAINING_FAILURES"
          echo "Historical success rate: $SUCCESS_RATE%"
          
          # Determine if we should continue the loop
          SHOULD_CONTINUE="false"
          
          if [[ $REMAINING_FAILURES -gt 0 ]] && [[ $CURRENT_ITERATION -lt 10 ]]; then
            # Check if we're making progress
            if [[ $(echo "$SUCCESS_RATE >= 30" | bc -l 2>/dev/null || echo "1") == "1" ]]; then
              SHOULD_CONTINUE="true"
              echo "âœ… Progress detected, continuing loop"
            else
              echo "âš ï¸  Low success rate, may need manual intervention"
            fi
          elif [[ $REMAINING_FAILURES -eq 0 ]]; then
            echo "âœ… All failures resolved!"
          else
            echo "âš ï¸  Maximum iterations reached"
          fi
          
          echo "should_continue_loop=$SHOULD_CONTINUE" >> $GITHUB_OUTPUT
          echo "repair_success_rate=$SUCCESS_RATE" >> $GITHUB_OUTPUT

      - name: Generate detailed report
        run: |
          echo "=== Verification Report ===" > verification_report.md
          echo "**Generated:** $(date -u +%Y-%m-%dT%H:%M:%SZ)" >> verification_report.md
          echo "**Triggered by:** ${{ inputs.triggered_by }}" >> verification_report.md
          echo "" >> verification_report.md
          
          echo "## Summary" >> verification_report.md
          echo "- **Current iteration:** ${{ steps.load_state.outputs.current_iteration }}" >> verification_report.md
          echo "- **Remaining failures:** ${{ steps.check.outputs.remaining_failures }}" >> verification_report.md
          echo "- **Historical success rate:** ${{ steps.load_state.outputs.success_rate }}%" >> verification_report.md
          echo "- **Should continue loop:** ${{ steps.analyze.outputs.should_continue_loop }}" >> verification_report.md
          echo "" >> verification_report.md
          
          if [[ ${{ steps.check.outputs.remaining_failures }} -gt 0 ]]; then
            echo "## Remaining Failed Workflows" >> verification_report.md
            echo '${{ steps.check.outputs.failed_runs }}' | jq -r '.[] | "- **\(.workflowName)** (ID: \(.databaseId), Updated: \(.updatedAt))"' >> verification_report.md
            echo "" >> verification_report.md
          fi
          
          # Add repair history summary
          if [[ -f .github/repair-state/repair-history.json ]]; then
            echo "## Recent Repairs" >> verification_report.md
            jq -r '.repairs[-5:] | .[] | "- **\(.error_type)** repair \(if .success then "âœ… succeeded" else "âŒ failed" end) (Run #\(.run_id), \(.timestamp))"' .github/repair-state/repair-history.json >> verification_report.md
          fi
          
          echo "Generated verification report"
          cat verification_report.md

      - name: Update loop state based on verification
        if: steps.analyze.outputs.should_continue_loop == 'false'
        run: |
          # Reset loop if no more failures or max iterations reached
          if [[ ${{ steps.check.outputs.remaining_failures }} -eq 0 ]]; then
            echo "All failures resolved, resetting loop state"
            jq '.iteration = 0 | .start_time = "" | .last_run = ""' .github/repair-state/loop-state.json > .github/repair-state/loop-state.json.tmp
            mv .github/repair-state/loop-state.json.tmp .github/repair-state/loop-state.json
          fi

      - name: Trigger next loop iteration
        if: steps.analyze.outputs.should_continue_loop == 'true'
        run: |
          echo "Triggering next repair loop iteration..."
          
          # Wait a bit before triggering to avoid race conditions
          sleep 30
          
          gh workflow run auto-repair-loop.yml \
            --repo ${{ github.repository }} \
            --field max_iterations="10" || {
            echo "Failed to trigger next loop iteration"
            exit 1
          }
          
          echo "âœ… Next loop iteration triggered"

  create-issue-if-stuck:
    name: Create Issue for Persistent Failures
    needs: verify-repairs
    if: needs.verify-repairs.outputs.remaining_failures != '0' && needs.verify-repairs.outputs.should_continue_loop == 'false'
    runs-on: ubuntu-latest
    
    steps:
      - name: Create issue for manual intervention
        run: |
          # Check if there's already an open issue for auto-repair
          EXISTING_ISSUE=$(gh issue list \
            --repo ${{ github.repository }} \
            --label "auto-repair" \
            --state open \
            --limit 1 \
            --json number \
            --jq '.[0].number // empty')
          
          if [[ -n "$EXISTING_ISSUE" ]]; then
            echo "Issue #$EXISTING_ISSUE already exists, updating it"
            
            gh issue comment $EXISTING_ISSUE \
              --repo ${{ github.repository }} \
              --body "## Auto-Repair Update - $(date -u +%Y-%m-%dT%H:%M:%SZ)
              
              The auto-repair system has completed its loop but there are still **${{ needs.verify-repairs.outputs.remaining_failures }}** remaining failures that require manual intervention.
              
              **Success Rate:** ${{ needs.verify-repairs.outputs.repair_success_rate }}%
              
              Please review the failed workflows and apply manual fixes."
          
          else
            echo "Creating new issue for manual intervention"
            
            gh issue create \
              --repo ${{ github.repository }} \
              --title "ðŸ”§ Auto-Repair: Manual Intervention Required" \
              --label "auto-repair,bug,help wanted" \
              --body "## Auto-Repair System Report
              
              The automatic repair system has completed its maximum iterations but **${{ needs.verify-repairs.outputs.remaining_failures }}** workflow failures remain unresolved.
              
              ### Summary
              - **Remaining failures:** ${{ needs.verify-repairs.outputs.remaining_failures }}
              - **Success rate:** ${{ needs.verify-repairs.outputs.repair_success_rate }}%
              - **Time:** $(date -u +%Y-%m-%dT%H:%M:%SZ)
              
              ### Next Steps
              1. Review the failed workflows listed above
              2. Identify patterns that the auto-repair system couldn't handle
              3. Apply manual fixes
              4. Consider updating the repair strategies in \`.github/workflows/parallel-repair.yml\`
              
              ### Auto-Repair System
              The system will resume automatically once these issues are resolved or you can trigger it manually with:
              \`\`\`bash
              gh workflow run auto-repair-loop.yml --field force_reset=true
              \`\`\`
              
              ðŸ¤– Generated with [Claude Code](https://claude.ai/code)"
          fi

  generate-metrics:
    name: Generate Repair Metrics
    needs: verify-repairs
    if: always()
    runs-on: ubuntu-latest
    
    steps:
      - name: Calculate and store metrics
        run: |
          echo "=== Auto-Repair System Metrics ==="
          echo "Timestamp: $(date -u +%Y-%m-%dT%H:%M:%SZ)"
          echo "Remaining Failures: ${{ needs.verify-repairs.outputs.remaining_failures }}"
          echo "Success Rate: ${{ needs.verify-repairs.outputs.repair_success_rate }}%"
          echo "Should Continue: ${{ needs.verify-repairs.outputs.should_continue_loop }}"
          
          # Could be extended to push metrics to monitoring systems
          # e.g., CloudWatch, Datadog, Prometheus, etc.
          
          echo "Metrics calculated and logged"