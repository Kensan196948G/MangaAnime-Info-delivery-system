name: Auto Repair Loop Controller

on:
  schedule:
    # Run every 30 minutes
    - cron: '*/30 * * * *'
  workflow_dispatch:
    inputs:
      force_reset:
        description: 'Force reset loop iteration counter'
        required: false
        default: 'false'
        type: choice
        options:
          - 'false'
          - 'true'
      max_iterations:
        description: 'Maximum iterations for this run'
        required: false
        default: '10'
        type: string

env:
  MAX_ITERATIONS: ${{ inputs.max_iterations || '10' }}

jobs:
  # 最小限の動作テストジョブ
  health-check:
    name: Health Check
    runs-on: ubuntu-22.04
    timeout-minutes: 5
    permissions:
      contents: read
      issues: read
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        
      - name: Basic environment test
        run: |
          echo "=== Environment Information ==="
          echo "OS: $(uname -a)"
          echo "Python version: $(python3 --version)"
          echo "Node version: $(node --version)"
          echo "Working directory: $(pwd)"
          echo "Repository structure:"
          ls -la
          echo "=== Test completed successfully ==="

  detect-failures:
    name: Detect Failed Workflows
    runs-on: ubuntu-22.04
    needs: health-check
    permissions:
      contents: write
      actions: write
      issues: write
      pull-requests: write
    outputs:
      failed_runs: ${{ steps.detect.outputs.failed_runs }}
      current_iteration: ${{ steps.state.outputs.current_iteration }}
      should_continue: ${{ steps.state.outputs.should_continue }}
    
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          token: ${{ secrets.GITHUB_TOKEN }}
          fetch-depth: 1

      - name: Setup GitHub CLI
        run: |
          gh --version
          gh auth status
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

      - name: Create repair state directory
        run: |
          mkdir -p .github/repair-state

      - name: Load loop state
        id: state
        run: |
          # Create state file if it doesn't exist
          if [[ ! -f .github/repair-state/loop-state.json ]]; then
            echo '{"iteration": 0, "start_time": "", "last_run": "", "total_repairs": 0}' > .github/repair-state/loop-state.json
          fi
          
          # Load current state
          CURRENT_ITERATION=$(jq -r '.iteration' .github/repair-state/loop-state.json)
          if [[ "$CURRENT_ITERATION" == "null" ]] || [[ -z "$CURRENT_ITERATION" ]]; then
            CURRENT_ITERATION=0
          fi
          
          # Reset if requested
          if [[ "${{ inputs.force_reset }}" == "true" ]]; then
            CURRENT_ITERATION=0
            echo "Force reset requested, setting iteration to 0"
          fi
          
          # Check if we should continue
          MAX_ITER="${{ env.MAX_ITERATIONS }}"
          if [[ $CURRENT_ITERATION -ge $MAX_ITER ]]; then
            echo "should_continue=false" >> $GITHUB_OUTPUT
            echo "Maximum iterations ($MAX_ITER) reached. Stopping loop."
          else
            echo "should_continue=true" >> $GITHUB_OUTPUT
          fi
          
          echo "current_iteration=$CURRENT_ITERATION" >> $GITHUB_OUTPUT
          echo "Current iteration: $CURRENT_ITERATION"

      - name: Detect failed workflows
        id: detect
        if: steps.state.outputs.should_continue == 'true'
        run: |
          echo "Detecting failed workflows..."
          
          # Get failed workflow runs from the last 24 hours
          echo "Fetching workflow runs..."
          FAILED_RUNS=$(gh run list \
            --status failure \
            --limit 10 \
            --json databaseId,workflowName,headBranch,conclusion,createdAt \
            --jq '.[] | select(.conclusion == "failure") | .databaseId' 2>/dev/null || echo "")
          
          echo "Raw failed runs: $FAILED_RUNS"
          
          # Convert to JSON array
          if [[ -n "$FAILED_RUNS" ]] && [[ "$FAILED_RUNS" != "" ]]; then
            FAILED_ARRAY=$(echo "$FAILED_RUNS" | jq -R . | jq -s . 2>/dev/null || echo '[]')
            echo "failed_runs=$FAILED_ARRAY" >> $GITHUB_OUTPUT
            echo "Found $(echo "$FAILED_RUNS" | wc -l) failed workflows"
            echo "$FAILED_RUNS"
          else
            echo "failed_runs=[]" >> $GITHUB_OUTPUT
            echo "No failed workflows found"
          fi
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

      - name: Update loop state
        if: steps.state.outputs.should_continue == 'true'
        run: |
          CURRENT_ITERATION=${{ steps.state.outputs.current_iteration }}
          NEW_ITERATION=$((CURRENT_ITERATION + 1))
          
          # Update state file
          TIMESTAMP=$(date -u +%Y-%m-%dT%H:%M:%SZ)
          jq --arg iter "$NEW_ITERATION" \
             --arg time "$TIMESTAMP" \
             --arg last "$TIMESTAMP" \
             '.iteration = ($iter | tonumber) | .last_run = $last | .start_time = (if (.start_time // "") == "" then $time else .start_time)' \
             .github/repair-state/loop-state.json > .github/repair-state/loop-state.json.tmp
          
          mv .github/repair-state/loop-state.json.tmp .github/repair-state/loop-state.json
          
          echo "Updated to iteration $NEW_ITERATION"

      - name: Store state artifact
        if: steps.state.outputs.should_continue == 'true'
        uses: actions/upload-artifact@v4
        with:
          name: repair-loop-state-${{ github.run_number }}
          path: .github/repair-state/
          retention-days: 7

  trigger-repairs:
    name: Trigger Parallel Repairs
    needs: detect-failures
    if: needs.detect-failures.outputs.should_continue == 'true' && needs.detect-failures.outputs.failed_runs != '[]'
    runs-on: ubuntu-22.04
    permissions:
      contents: read
      actions: write
    
    strategy:
      matrix:
        run_id: ${{ fromJson(needs.detect-failures.outputs.failed_runs) }}
      max-parallel: 5
      fail-fast: false
    
    steps:
      - name: Trigger repair workflow
        run: |
          gh workflow run parallel-repair.yml \
            --repo ${{ github.repository }} \
            --field run_id=${{ matrix.run_id }} \
            --field iteration=${{ needs.detect-failures.outputs.current_iteration }}
          
          echo "Triggered repair for run ID: ${{ matrix.run_id }}"
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

  schedule-verification:
    name: Schedule Verification
    needs: [detect-failures, trigger-repairs]
    if: always() && needs.detect-failures.outputs.should_continue == 'true'
    runs-on: ubuntu-22.04
    permissions:
      contents: read
      actions: write
    
    steps:
      - name: Wait and trigger verification
        run: |
          echo "Scheduling verification workflow in 35 minutes..."
          # The verification workflow runs on its own cron, but we can also trigger it
          sleep 10 # Brief pause to ensure repairs are triggered
          
          gh workflow run verify-repair.yml \
            --repo ${{ github.repository }} \
            --field triggered_by="auto-repair-loop" \
            --field iteration=${{ needs.detect-failures.outputs.current_iteration }}
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

  status-report:
    name: Status Report
    needs: [detect-failures, trigger-repairs]
    if: always()
    runs-on: ubuntu-22.04
    permissions:
      contents: read
    
    steps:
      - name: Generate status report
        run: |
          echo "=== Auto Repair Loop Status ==="
          echo "Iteration: ${{ needs.detect-failures.outputs.current_iteration }}"
          echo "Should Continue: ${{ needs.detect-failures.outputs.should_continue }}"
          echo "Failed Runs Found: ${{ needs.detect-failures.outputs.failed_runs }}"
          echo "Repairs Triggered: ${{ needs.trigger-repairs.result }}"
          echo "Time: $(date -u +%Y-%m-%dT%H:%M:%SZ)"
          
          if [[ "${{ needs.detect-failures.outputs.should_continue }}" == "false" ]]; then
            echo "⚠️  Maximum iterations reached. Manual intervention may be required."
          fi