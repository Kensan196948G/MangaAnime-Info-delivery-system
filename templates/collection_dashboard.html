{% extends "base.html" %}

{% block title %}収集状況ダッシュボード - アニメ・マンガ情報配信システム{% endblock %}

{% block head %}
<style>
/* Bootstrap Grid Fallback - CRITICAL FIX */
.row {
    display: flex !important;
    flex-wrap: wrap !important;
    margin: 0 -15px !important;
}

.col-md-6 {
    position: relative !important;
    width: 100% !important;
    padding: 0 15px !important;
    flex: 0 0 50% !important;
    max-width: 50% !important;
}

.col-12 {
    position: relative !important;
    width: 100% !important;
    padding: 0 15px !important;
    flex: 0 0 100% !important;
    max-width: 100% !important;
}

.d-flex {
    display: flex !important;
}

.align-items-center {
    align-items: center !important;
}

.justify-content-between {
    justify-content: space-between !important;
}

.p-3 {
    padding: 1rem !important;
}

.border {
    border: 1px solid #dee2e6 !important;
}

.rounded {
    border-radius: 0.375rem !important;
}

.mb-3 {
    margin-bottom: 1rem !important;
}

.me-3 {
    margin-right: 1rem !important;
}

.text-end {
    text-align: right !important;
}

.collection-status-card {
    transition: all 0.3s ease;
    border-left: 4px solid transparent;
}

.collection-status-card.status-running {
    border-left-color: #198754;
    background-color: rgba(25, 135, 84, 0.05);
}

.collection-status-card.status-error {
    border-left-color: #dc3545;
    background-color: rgba(220, 53, 69, 0.05);
}

.collection-status-card.status-idle {
    border-left-color: #6c757d;
    background-color: rgba(108, 117, 125, 0.05);
}

.progress-ring {
    transform: rotate(-90deg);
}

.progress-ring-circle {
    stroke: #e9ecef;
    fill: transparent;
    stroke-width: 4;
    stroke-linecap: round;
    transition: stroke-dasharray 0.5s ease;
}

.progress-ring-circle.active {
    stroke: #0d6efd;
}

.pulse-dot {
    display: inline-block;
    width: 8px;
    height: 8px;
    border-radius: 50%;
    margin-right: 6px;
}

/* スピナーアニメーション */
.spin {
    animation: spin 1s linear infinite;
}

@keyframes spin {
    from {
        transform: rotate(0deg);
    }
    to {
        transform: rotate(360deg);
    }
}

/* ボタン無効化時のスタイル */
.btn:disabled {
    opacity: 0.65;
    cursor: not-allowed;
}

/* API接続状況のローディング表示 */
.api-loading {
    text-align: center;
    padding: 20px;
    color: #6c757d;
}

.pulse-dot.running {
    background-color: #198754;
    animation: pulse 1.5s infinite;
}

.pulse-dot.error {
    background-color: #dc3545;
    animation: pulse-error 1s infinite;
}

.pulse-dot.idle {
    background-color: #6c757d;
}

@keyframes pulse {
    0% { opacity: 1; transform: scale(1); }
    50% { opacity: 0.6; transform: scale(1.2); }
    100% { opacity: 1; transform: scale(1); }
}

@keyframes pulse-error {
    0% { opacity: 1; }
    50% { opacity: 0.4; }
    100% { opacity: 1; }
}

.log-container {
    max-height: 300px;
    overflow-y: auto;
    background: #f8f9fa;
    border-radius: 0.375rem;
    font-family: 'Courier New', monospace;
    font-size: 0.85rem;
}

.log-entry {
    padding: 4px 12px;
    border-bottom: 1px solid #e9ecef;
    white-space: nowrap;
    overflow-x: auto;
}

.log-entry.info { color: #0d6efd; }
.log-entry.warning { color: #fd7e14; }
.log-entry.error { color: #dc3545; }
.log-entry.success { color: #198754; }

.metric-value {
    font-size: 2rem;
    font-weight: bold;
    line-height: 1;
}

.metric-change {
    font-size: 0.8rem;
    font-weight: 500;
}

.metric-change.positive { color: #198754; }
.metric-change.negative { color: #dc3545; }

.connection-indicator {
    display: flex;
    align-items: center;
    gap: 8px;
    padding: 8px 12px;
    border-radius: 6px;
    transition: all 0.3s ease;
}

.connection-indicator.connected {
    background-color: rgba(25, 135, 84, 0.1);
    color: #198754;
}

.connection-indicator.disconnected {
    background-color: rgba(220, 53, 69, 0.1);
    color: #dc3545;
}

.connection-indicator.testing {
    background-color: rgba(255, 193, 7, 0.1);
    color: #ffc107;
}
</style>
{% endblock %}

{% block content %}
<div class="container-fluid py-4">
    <!-- ページヘッダー -->
    <div class="d-flex justify-content-between align-items-center mb-4">
        <div>
            <h1 class="h3 mb-1">収集状況ダッシュボード</h1>
            <p class="text-muted mb-0">リアルタイムで収集プロセスの状況を監視</p>
        </div>
        <div class="d-flex gap-2">
            <button id="refresh-btn" class="btn btn-outline-primary">
                <i class="bi bi-arrow-clockwise"></i> 更新
            </button>
            <button id="manual-collect-btn" class="btn btn-primary">
                <i class="bi bi-play-circle"></i> 手動収集開始
            </button>
        </div>
    </div>

    <!-- システム状態概要 -->
    <div class="row mb-4">
        <div class="col-md-3">
            <div class="card collection-status-card status-running h-100">
                <div class="card-body text-center">
                    <div class="pulse-dot running"></div>
                    <h5 class="card-title mb-3">システム状態</h5>
                    <div class="metric-value text-success" id="system-status">稼働中</div>
                    <small class="text-muted" id="system-uptime">稼働時間: 2時間15分</small>
                </div>
            </div>
        </div>
        <div class="col-md-3">
            <div class="card collection-status-card h-100">
                <div class="card-body text-center">
                    <h5 class="card-title">今日の収集数</h5>
                    <div class="metric-value text-primary" id="today-collected">127</div>
                    <div class="metric-change positive">
                        <i class="bi bi-arrow-up"></i> +23 (前日比)
                    </div>
                </div>
            </div>
        </div>
        <div class="col-md-3">
            <div class="card collection-status-card h-100">
                <div class="card-body text-center">
                    <h5 class="card-title">処理待ち</h5>
                    <div class="metric-value text-warning" id="pending-count">8</div>
                    <div class="metric-change">
                        <i class="bi bi-clock"></i> 平均待ち時間: 2分
                    </div>
                </div>
            </div>
        </div>
        <div class="col-md-3">
            <div class="card collection-status-card h-100">
                <div class="card-body text-center">
                    <h5 class="card-title">エラー数</h5>
                    <div class="metric-value text-danger" id="error-count">3</div>
                    <div class="metric-change negative">
                        <i class="bi bi-exclamation-triangle"></i> 要確認
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- 収集プロセス状況 -->
    <div class="row mb-4">
        <div class="col-lg-8">
            <div class="card">
                <div class="card-header d-flex justify-content-between align-items-center">
                    <h5 class="mb-0">収集プロセス状況</h5>
                    <div class="btn-group btn-group-sm">
                        <button class="btn btn-outline-secondary active" data-filter="all">すべて</button>
                        <button class="btn btn-outline-secondary" data-filter="anime">アニメ</button>
                        <button class="btn btn-outline-secondary" data-filter="manga">マンガ</button>
                    </div>
                </div>
                <div class="card-body">
                    <div class="row" id="collection-processes">
                        <!-- Collection processes will be loaded dynamically -->
                        <div class="col-12 text-center" id="collection-processes-loading">
                            <div class="spinner-border spinner-border-sm text-primary" role="status">
                                <span class="visually-hidden">Loading...</span>
                            </div>
                            <div class="mt-2">収集プロセス状況を読み込み中...</div>
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <div class="col-lg-4">
            <div class="card">
                <div class="card-header d-flex justify-content-between align-items-center">
                    <h5 class="mb-0">API接続状況</h5>
                    <button class="btn btn-sm btn-outline-primary" id="retry-api-connections" type="button">
                        <i class="bi bi-arrow-clockwise" id="retry-icon"></i>
                        <span id="retry-text">再試行</span>
                    </button>
                </div>
                <div class="card-body" id="api-status-container">
                    <!-- API status will be loaded dynamically -->
                    <div class="mb-3">
                        <div class="d-flex justify-content-between align-items-center mb-2">
                            <span>API接続状況を読み込み中...</span>
                            <span class="badge bg-secondary">確認中</span>
                        </div>
                        <div class="progress mb-2" style="height: 4px;">
                            <div class="progress-bar bg-secondary" style="width: 0%;"></div>
                        </div>
                        <small class="text-muted">接続テスト実行中...</small>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- リアルタイムログ -->
    <div class="card">
        <div class="card-header d-flex justify-content-between align-items-center">
            <h5 class="mb-0">リアルタイムログ</h5>
            <div class="d-flex gap-2">
                <select class="form-select form-select-sm" id="log-level-filter" style="width: auto;">
                    <option value="all">すべて</option>
                    <option value="info">情報</option>
                    <option value="warning">警告</option>
                    <option value="error">エラー</option>
                    <option value="success">成功</option>
                </select>
                <button class="btn btn-sm btn-outline-secondary" id="clear-log-btn">
                    <i class="bi bi-trash"></i> クリア
                </button>
                <div class="form-check form-switch">
                    <input class="form-check-input" type="checkbox" id="auto-scroll" checked>
                    <label class="form-check-label" for="auto-scroll">自動スクロール</label>
                </div>
            </div>
        </div>
        <div class="card-body p-0">
            <div class="log-container" id="log-container">
                <!-- Real-time log entries will be loaded here -->
                <div class="log-entry info" id="loading-logs">[読み込み中...] システムログを取得しています...</div>
            </div>
        </div>
    </div>
</div>
{% endblock %}

{% block scripts %}
<script>
document.addEventListener('DOMContentLoaded', function() {
    console.log('DOM Content Loaded - starting initialization...');
    
    // リアルタイム更新用WebSocket接続
    let socket = null;
    let reconnectTimer = null;
    
    function connectWebSocket() {
        // Use HTTP polling instead of WebSocket
        console.log('Starting HTTP polling for real-time updates');
        pollForUpdates();
        loadRealtimeLogs(); // Load logs initially
        setInterval(pollForUpdates, 15000); // Poll every 15 seconds (reduced frequency)
        setInterval(loadRealtimeLogs, 30000); // Update logs every 30 seconds
        updateConnectionStatus('connected');
    }
    
    function pollForUpdates() {
        // Fast polling with timeout
        const controller = new AbortController();
        const timeoutId = setTimeout(() => controller.abort(), 5000); // 5 second timeout
        
        fetch('/api/collection-status', { signal: controller.signal })
            .then(response => {
                clearTimeout(timeoutId);
                if (!response.ok) {
                    throw new Error('Network response was not ok');
                }
                return response.json();
            })
            .then(data => {
                handleRealtimeUpdate(data);
                updateConnectionStatus('connected');
            })
            .catch(error => {
                clearTimeout(timeoutId);
                if (error.name === 'AbortError') {
                    console.warn('API request timed out');
                } else {
                    console.error('Error fetching collection status:', error);
                }
                updateConnectionStatus('error');
            });
    }
    
    function handleRealtimeUpdate(data) {
        // Handle API response from /api/collection-status
        if (data.metrics) {
            updateCollectionMetrics(data.metrics);
        }
        if (data.apiStatus) {
            updateApiStatus(data.apiStatus);
        }
        
        // Also load real-time logs and collection processes
        loadRealtimeLogs();
        loadCollectionProcesses();
    }
    
    function loadRealtimeLogs() {
        fetch('/api/realtime-logs?limit=20')
            .then(response => {
                if (!response.ok) {
                    throw new Error('Network response was not ok');
                }
                return response.json();
            })
            .then(logs => {
                updateLogDisplay(logs);
            })
            .catch(error => {
                console.error('Error loading real-time logs:', error);
                displayLogError('リアルタイムログの読み込みに失敗しました');
            });
    }
    
    function loadCollectionProcesses() {
        console.log('Loading collection processes...');
        const loadingElement = document.getElementById('collection-processes-loading');
        if (loadingElement) {
            loadingElement.innerHTML = '<i class="bi bi-hourglass-split spin"></i> 収集プロセス状況を読み込み中...';
        }
        
        fetch('/api/collection-processes')
            .then(response => {
                console.log('Collection processes response:', response.status);
                if (!response.ok) {
                    throw new Error('Network response was not ok');
                }
                return response.json();
            })
            .then(data => {
                console.log('Collection processes data:', data);
                if (loadingElement) {
                    loadingElement.style.display = 'none';
                }
                updateCollectionProcesses(data);
            })
            .catch(error => {
                console.error('Error loading collection processes:', error);
                displayCollectionProcessError('収集プロセス情報の読み込みに失敗しました: ' + error.message);
            });
    }
    
    function updateCollectionProcesses(processes) {
        console.log('Updating collection processes:', processes);
        const container = document.getElementById('collection-processes');
        const loadingElement = document.getElementById('collection-processes-loading');
        
        if (!container) {
            console.error('Collection processes container not found');
            return;
        }
        
        // Remove loading indicator
        if (loadingElement) {
            loadingElement.remove();
        }
        
        // Clear existing content
        container.innerHTML = '';
        
        // Create process cards
        console.log('Creating process cards for', processes.length, 'processes');
        processes.forEach((process, index) => {
            console.log('Creating card for process:', process.name);
            const processCard = createProcessCard(process.id, process, process);
            console.log('Created card:', processCard);
            container.appendChild(processCard);
        });
        
        console.log('Final container HTML:', container.innerHTML.substring(0, 200) + '...');
        
        // Add event listeners for retry buttons
        container.querySelectorAll('.retry-process-btn').forEach(button => {
            button.addEventListener('click', function(e) {
                e.preventDefault();
                const processId = this.getAttribute('data-process-id');
                retryCollectionProcess(processId, this);
            });
        });
    }
    
    function createProcessCard(processId, process, status) {
        console.log('createProcessCard called with:', processId, process, status);
        const col = document.createElement('div');
        col.className = 'col-md-6 mb-3';
        col.setAttribute('data-type', process.type || 'general');
        
        console.log('Created col element:', col);
        
        // Determine status indicators
        let statusClass, statusIcon, statusText, buttonHtml = '';
        
        if (status.status === 'connected') {
            statusClass = 'connected';
            statusIcon = 'bi-check-circle';
            statusText = '正常';
        } else if (status.status === 'warning') {
            statusClass = 'testing';
            statusIcon = 'bi-exclamation-triangle';
            statusText = '警告';
        } else {
            statusClass = 'disconnected';
            statusIcon = 'bi-exclamation-circle';
            statusText = 'エラー';
            buttonHtml = `
                <button class="btn btn-sm btn-outline-danger retry-process-btn" data-process-id="${processId}">
                    <i class="bi bi-arrow-clockwise"></i> 再試行
                </button>
            `;
        }
        
        // Calculate progress percentage (based on success rate)
        const progressPercent = status.success_rate || 0;
        const circumference = 2 * Math.PI * 16; // radius = 16
        const strokeDasharray = (progressPercent / 100) * circumference;
        const strokeDashoffset = circumference - strokeDasharray;
        
        col.innerHTML = `
            <div class="d-flex align-items-center justify-content-between p-3 border rounded">
                <div class="d-flex align-items-center">
                    <div class="connection-indicator ${statusClass} me-3">
                        <i class="${statusIcon}"></i>
                        <span>${statusText}</span>
                    </div>
                    <div>
                        <h6 class="mb-0">${process.name}</h6>
                        <small class="text-muted">${process.type}</small>
                        <small class="text-muted d-block">最終更新: ${process.last_update}</small>
                    </div>
                </div>
                <div class="text-end">
                    ${progressPercent > 0 ? `
                        <div class="progress-container position-relative">
                            <svg class="progress-ring" width="40" height="40">
                                <circle class="progress-ring-circle ${status.status === 'connected' ? 'active' : ''}" 
                                        cx="20" cy="20" r="16"
                                        stroke-dasharray="${strokeDasharray} ${strokeDashoffset}"></circle>
                            </svg>
                            <div class="position-absolute top-50 start-50 translate-middle">
                                <small class="text-${status.status === 'connected' ? 'primary' : status.status === 'warning' ? 'warning' : 'danger'} fw-bold">${progressPercent}%</small>
                            </div>
                        </div>
                        <small class="text-muted d-block">${status.response_time}</small>
                    ` : ''}
                    ${buttonHtml}
                    ${status.status === 'error' ? `<small class="text-danger d-block">${status.note || '接続タイムアウト'}</small>` : 
                      status.note ? `<small class="text-success d-block">${status.note}</small>` : ''}
                </div>
            </div>
        `;
        
        console.log('Final card HTML:', col.outerHTML.substring(0, 150) + '...');
        return col;
    }
    
    function displayCollectionProcessError(message) {
        const container = document.getElementById('collection-processes');
        const loadingElement = document.getElementById('collection-processes-loading');
        
        if (loadingElement) {
            loadingElement.remove();
        }
        
        container.innerHTML = `
            <div class="col-12">
                <div class="alert alert-warning">
                    <i class="bi bi-exclamation-triangle"></i>
                    ${message}
                </div>
            </div>
        `;
    }
    
    function retryCollectionProcess(processId, buttonElement) {
        // ボタンを無効化してスピナーを表示
        buttonElement.disabled = true;
        const originalHtml = buttonElement.innerHTML;
        buttonElement.innerHTML = '<i class="bi bi-arrow-clockwise spin"></i> 再試行中...';
        
        // 該当プロセスの表示を更新中に変更
        const processCard = buttonElement.closest('.col-md-6');
        const statusIndicator = processCard.querySelector('.connection-indicator');
        const originalStatusClass = statusIndicator.className;
        
        statusIndicator.className = 'connection-indicator testing me-3';
        statusIndicator.innerHTML = '<i class="bi bi-hourglass-split spin"></i><span>テスト中...</span>';
        
        // プロセス再試行API呼び出し
        fetch('/api/collection-processes/retry', {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json'
            },
            body: JSON.stringify({ process_id: processId })
        })
        .then(response => response.json())
        .then(data => {
            if (data.success) {
                // 成功時は成功状態を表示
                statusIndicator.className = 'connection-indicator connected me-3';
                statusIndicator.innerHTML = '<i class="bi bi-check-circle"></i><span>正常</span>';
                
                // ボタンを非表示にする
                buttonElement.style.display = 'none';
                
                // 成功メッセージを表示
                const errorMsg = processCard.querySelector('.text-danger');
                if (errorMsg) {
                    errorMsg.className = 'text-success small';
                    errorMsg.textContent = '接続が復旧しました';
                }
            } else {
                throw new Error(data.message || 'Unknown error');
            }
        })
        .catch(error => {
            console.error('Error retrying collection process:', error);
            
            // エラー時は元の状態に戻す
            statusIndicator.className = originalStatusClass;
            statusIndicator.innerHTML = '<i class="bi bi-exclamation-circle"></i><span>エラー</span>';
        })
        .finally(() => {
            // ボタンを元に戻す
            setTimeout(() => {
                buttonElement.disabled = false;
                buttonElement.innerHTML = originalHtml;
            }, 1500);
        });
    }
    
    function updateLogDisplay(logs) {
        const logContainer = document.getElementById('log-container');
        if (!logContainer) return;
        
        // Clear existing logs
        logContainer.innerHTML = '';
        
        // Add new logs
        logs.forEach(log => {
            const logEntry = document.createElement('div');
            logEntry.className = `log-entry ${log.level.toLowerCase()}`;
            logEntry.textContent = log.formatted;
            logContainer.appendChild(logEntry);
        });
        
        // Auto-scroll if enabled
        const autoScroll = document.getElementById('auto-scroll');
        if (autoScroll && autoScroll.checked) {
            logContainer.scrollTop = logContainer.scrollHeight;
        }
    }
    
    function displayLogError(message) {
        const logContainer = document.getElementById('log-container');
        if (!logContainer) return;
        
        const errorEntry = document.createElement('div');
        errorEntry.className = 'log-entry error';
        errorEntry.textContent = `[${new Date().toLocaleString()}] ERROR: ${message}`;
        logContainer.appendChild(errorEntry);
    }
    
    function updateCollectionMetrics(metrics) {
        // Update collection metrics on dashboard
        if (metrics.todayCollected !== undefined) {
            const element = document.querySelector('#today-collected-count');
            if (element) element.textContent = metrics.todayCollected;
        }
        if (metrics.pendingCount !== undefined) {
            const element = document.querySelector('#pending-count');
            if (element) element.textContent = metrics.pendingCount;
        }
        if (metrics.errorCount !== undefined) {
            const element = document.querySelector('#error-count');
            if (element) element.textContent = metrics.errorCount;
        }
        if (metrics.systemUptime !== undefined) {
            const element = document.querySelector('#system-uptime');
            if (element) element.textContent = metrics.systemUptime;
        }
    }
    
    function updateApiStatus(apiStatus) {
        console.log('Updating API status:', apiStatus);
        const container = document.getElementById('api-status-container');
        if (!container) {
            console.error('API status container not found');
            return;
        }
        
        // Clear existing content
        container.innerHTML = '';
        
        // API name mapping
        const apiNames = {
            'anilist': 'AniList GraphQL',
            'shobo': 'しょぼいカレンダー',
            'bookwalker': 'BookWalker RSS (代替: Yahoo News)',
            'other_rss': 'その他RSSフィード (代替: NHK News)'
        };
        
        // Create status display for each API
        for (const [api, status] of Object.entries(apiStatus)) {
            const apiName = apiNames[api] || api;
            const statusDiv = document.createElement('div');
            statusDiv.className = 'mb-3';
            
            // Determine status color and text
            let statusClass, statusText, progressClass;
            if (status.status === 'connected') {
                statusClass = 'bg-success';
                statusText = '正常';
                progressClass = 'bg-success';
            } else if (status.status === 'warning') {
                statusClass = 'bg-warning';
                statusText = '警告';
                progressClass = 'bg-warning';
            } else {
                statusClass = 'bg-danger';
                statusText = 'エラー';
                progressClass = 'bg-danger';
            }
            
            // Add note if available
            const note = status.note ? ` (${status.note})` : '';
            
            statusDiv.innerHTML = `
                <div class="d-flex justify-content-between align-items-center mb-2">
                    <span>${apiName}${note}</span>
                    <div class="d-flex align-items-center gap-2">
                        <span class="badge ${statusClass}">${statusText}</span>
                        ${status.status === 'error' ? `<button class="btn btn-xs btn-outline-secondary retry-single-api" data-api="${api}" style="font-size: 10px; padding: 2px 6px;"><i class="bi bi-arrow-clockwise"></i></button>` : ''}
                    </div>
                </div>
                <div class="progress mb-2" style="height: 4px;">
                    <div class="progress-bar ${progressClass}" style="width: ${status.success_rate}%;"></div>
                </div>
                <small class="text-muted">レスポンス時間: ${status.response_time}ms | 成功率: ${status.success_rate}%</small>
            `;
            
            container.appendChild(statusDiv);
        }
        
        // Add last updated timestamp
        const lastUpdated = document.createElement('div');
        lastUpdated.className = 'text-muted small mt-2';
        lastUpdated.innerHTML = `<i class="bi bi-clock"></i> 最終更新: ${new Date().toLocaleString()}`;
        container.appendChild(lastUpdated);
        
        // 個別再試行ボタンのイベントリスナーを追加
        container.querySelectorAll('.retry-single-api').forEach(button => {
            button.addEventListener('click', function() {
                const apiName = this.getAttribute('data-api');
                retrySingleApi(apiName, this);
            });
        });
    }
    
    function retrySingleApi(apiName, buttonElement) {
        // ボタンを無効化してスピナーを表示
        buttonElement.disabled = true;
        buttonElement.innerHTML = '<i class="bi bi-arrow-clockwise spin"></i>';
        
        // 該当APIの表示を更新中に変更
        const statusDiv = buttonElement.closest('.mb-3');
        const badge = statusDiv.querySelector('.badge');
        const originalBadgeClass = badge.className;
        const originalBadgeText = badge.textContent;
        
        badge.className = 'badge bg-warning';
        badge.textContent = 'テスト中...';
        
        // API接続状況を更新
        fetch('/api/collection-status')
            .then(response => response.json())
            .then(data => {
                if (data.apiStatus && data.apiStatus[apiName]) {
                    // 個別のAPIステータスを更新
                    updateSingleApiStatus(apiName, data.apiStatus[apiName], statusDiv);
                }
            })
            .catch(error => {
                console.error('Error retrying single API:', error);
                // エラー時は元の状態に戻す
                badge.className = originalBadgeClass;
                badge.textContent = originalBadgeText;
            })
            .finally(() => {
                // ボタンを元に戻す
                setTimeout(() => {
                    buttonElement.disabled = false;
                    buttonElement.innerHTML = '<i class="bi bi-arrow-clockwise"></i>';
                }, 1000);
            });
    }
    
    function updateSingleApiStatus(apiName, status, statusDiv) {
        const badge = statusDiv.querySelector('.badge');
        const progressBar = statusDiv.querySelector('.progress-bar');
        const detailText = statusDiv.querySelector('.text-muted');
        
        // ステータスに応じてバッジを更新
        let statusClass, statusText, progressClass;
        if (status.status === 'connected') {
            statusClass = 'bg-success';
            statusText = '正常';
            progressClass = 'bg-success';
        } else if (status.status === 'warning') {
            statusClass = 'bg-warning';
            statusText = '警告';
            progressClass = 'bg-warning';
        } else {
            statusClass = 'bg-danger';
            statusText = 'エラー';
            progressClass = 'bg-danger';
        }
        
        badge.className = `badge ${statusClass}`;
        badge.textContent = statusText;
        progressBar.className = `progress-bar ${progressClass}`;
        progressBar.style.width = `${status.success_rate}%`;
        detailText.textContent = `レスポンス時間: ${status.response_time}ms | 成功率: ${status.success_rate}%`;
    }
    
    function updateCollectionStatus(data) {
        // 収集プロセスの状況を更新
        const processElement = document.querySelector(`[data-source="${data.source}"]`);
        if (processElement) {
            const progressCircle = processElement.querySelector('.progress-ring-circle');
            const progressText = processElement.querySelector('.progress-text');
            const statusIndicator = processElement.querySelector('.connection-indicator');
            
            if (progressCircle) {
                const circumference = 2 * Math.PI * 16;
                const offset = circumference - (data.progress / 100) * circumference;
                progressCircle.style.strokeDasharray = `${circumference - offset} ${offset}`;
            }
            
            if (progressText) {
                progressText.textContent = `${data.progress}%`;
            }
            
            if (statusIndicator) {
                statusIndicator.className = `connection-indicator ${data.status}`;
                const statusText = statusIndicator.querySelector('span');
                const statusIcon = statusIndicator.querySelector('i');
                
                if (statusText && statusIcon) {
                    switch (data.status) {
                        case 'connected':
                            statusText.textContent = '接続中';
                            statusIcon.className = 'bi bi-check-circle';
                            break;
                        case 'testing':
                            statusText.textContent = '処理中';
                            statusIcon.className = 'bi bi-hourglass-split';
                            break;
                        case 'disconnected':
                            statusText.textContent = 'エラー';
                            statusIcon.className = 'bi bi-exclamation-circle';
                            break;
                    }
                }
            }
        }
    }
    
    function addLogEntry(data) {
        const logContainer = document.getElementById('log-container');
        const autoScroll = document.getElementById('auto-scroll').checked;
        const levelFilter = document.getElementById('log-level-filter').value;
        
        // フィルタリング
        if (levelFilter !== 'all' && data.level !== levelFilter) {
            return;
        }
        
        const logEntry = document.createElement('div');
        logEntry.className = `log-entry ${data.level}`;
        logEntry.textContent = `[${data.timestamp}] ${data.level.toUpperCase()}: ${data.message}`;
        
        logContainer.appendChild(logEntry);
        
        // 最大ログ数を制限 (パフォーマンス対策)
        const logEntries = logContainer.querySelectorAll('.log-entry');
        if (logEntries.length > 500) {
            logEntries[0].remove();
        }
        
        // 自動スクロール
        if (autoScroll) {
            logContainer.scrollTop = logContainer.scrollHeight;
        }
    }
    
    function updateMetrics(data) {
        // メトリクス表示を更新
        if (data.todayCollected !== undefined) {
            document.getElementById('today-collected').textContent = data.todayCollected;
        }
        if (data.pendingCount !== undefined) {
            document.getElementById('pending-count').textContent = data.pendingCount;
        }
        if (data.errorCount !== undefined) {
            document.getElementById('error-count').textContent = data.errorCount;
        }
        if (data.systemUptime !== undefined) {
            document.getElementById('system-uptime').textContent = `稼働時間: ${data.systemUptime}`;
        }
    }
    
    // updateApiStatus function is defined above - removed duplicate
    
    function updateConnectionStatus(status) {
        const statusIndicator = document.getElementById('status-indicator');
        if (status === 'connected') {
            statusIndicator.innerHTML = '<i class="bi bi-circle-fill" aria-hidden="true"></i> システム稼働中';
            statusIndicator.className = 'badge bg-success';
        } else {
            statusIndicator.innerHTML = '<i class="bi bi-circle-fill" aria-hidden="true"></i> 接続エラー';
            statusIndicator.className = 'badge bg-danger';
        }
    }
    
    // ポーリング更新 (WebSocketのフォールバック)
    function pollForUpdates() {
        fetch('/api/collection-status')
            .then(response => response.json())
            .then(data => {
                updateMetrics(data.metrics);
                updateApiStatus(data.apiStatus);
                
                // 定期的にポーリング
                setTimeout(pollForUpdates, 10000);
            })
            .catch(error => {
                console.error('Polling failed:', error);
                setTimeout(pollForUpdates, 15000);
            });
    }
    
    // イベントリスナー
    document.getElementById('refresh-btn').addEventListener('click', function() {
        location.reload();
    });
    
    document.getElementById('manual-collect-btn').addEventListener('click', function() {
        const button = this;
        button.disabled = true;
        button.innerHTML = '<i class="bi bi-hourglass-split"></i> 収集中...';
        
        fetch('/api/manual-collection', { method: 'POST' })
            .then(response => response.json())
            .then(data => {
                if (data.success) {
                    addLogEntry({
                        timestamp: new Date().toISOString().slice(0, 19).replace('T', ' '),
                        level: 'info',
                        message: '手動収集が開始されました'
                    });
                }
            })
            .catch(error => {
                console.error('Manual collection failed:', error);
                addLogEntry({
                    timestamp: new Date().toISOString().slice(0, 19).replace('T', ' '),
                    level: 'error',
                    message: '手動収集の開始に失敗しました'
                });
            })
            .finally(() => {
                button.disabled = false;
                button.innerHTML = '<i class="bi bi-play-circle"></i> 手動収集開始';
            });
    });
    
    // フィルター機能
    document.getElementById('log-level-filter').addEventListener('change', function() {
        const selectedLevel = this.value;
        const logEntries = document.querySelectorAll('.log-entry');
        
        logEntries.forEach(entry => {
            if (selectedLevel === 'all') {
                entry.style.display = 'block';
            } else {
                entry.style.display = entry.classList.contains(selectedLevel) ? 'block' : 'none';
            }
        });
    });
    
    // プロセスフィルター
    document.querySelectorAll('[data-filter]').forEach(button => {
        button.addEventListener('click', function() {
            document.querySelectorAll('[data-filter]').forEach(b => b.classList.remove('active'));
            this.classList.add('active');
            
            const filter = this.dataset.filter;
            const processes = document.querySelectorAll('#collection-processes [data-type]');
            
            processes.forEach(process => {
                if (filter === 'all' || process.dataset.type === filter) {
                    process.style.display = 'block';
                } else {
                    process.style.display = 'none';
                }
            });
        });
    });
    
    // ログクリア
    document.getElementById('clear-log-btn').addEventListener('click', function() {
        if (confirm('ログをクリアしますか？')) {
            document.getElementById('log-container').innerHTML = '';
        }
    });
    
    // 再試行ボタンのイベントリスナー
    document.getElementById('retry-api-connections').addEventListener('click', function() {
        retryApiConnections();
    });
    
    function retryApiConnections() {
        const button = document.getElementById('retry-api-connections');
        const icon = document.getElementById('retry-icon');
        const text = document.getElementById('retry-text');
        
        // ボタンの状態を「確認中」に変更
        button.disabled = true;
        button.className = 'btn btn-sm btn-secondary';
        icon.className = 'bi bi-arrow-clockwise spin';
        text.textContent = '確認中...';
        
        // API status containerにローディング表示
        const container = document.getElementById('api-status-container');
        container.innerHTML = `
            <div class="mb-3 text-center">
                <div class="spinner-border spinner-border-sm text-primary" role="status">
                    <span class="visually-hidden">Loading...</span>
                </div>
                <div class="mt-2">API接続テスト実行中...</div>
            </div>
        `;
        
        // API接続状況を強制更新
        fetch('/api/collection-status')
            .then(response => {
                if (!response.ok) {
                    throw new Error('Network response was not ok');
                }
                return response.json();
            })
            .then(data => {
                if (data.apiStatus) {
                    updateApiStatus(data.apiStatus);
                }
                // ボタンの状態を元に戻す
                resetRetryButton();
            })
            .catch(error => {
                console.error('Error during API retry:', error);
                // エラー時もボタンを元に戻す
                resetRetryButton();
                displayApiError('API接続テストに失敗しました');
            });
    }
    
    function resetRetryButton() {
        const button = document.getElementById('retry-api-connections');
        const icon = document.getElementById('retry-icon');
        const text = document.getElementById('retry-text');
        
        setTimeout(() => {
            button.disabled = false;
            button.className = 'btn btn-sm btn-outline-primary';
            icon.className = 'bi bi-arrow-clockwise';
            text.textContent = '再試行';
        }, 1000); // 1秒後にボタンを再有効化
    }
    
    function displayApiError(message) {
        const container = document.getElementById('api-status-container');
        const errorDiv = document.createElement('div');
        errorDiv.className = 'alert alert-danger';
        errorDiv.innerHTML = `
            <i class="bi bi-exclamation-triangle"></i>
            ${message}
        `;
        container.appendChild(errorDiv);
    }
    
    // テスト関数をグローバルに公開
    window.testLoadCollection = function() {
        console.log('Manual test: Loading collection processes');
        loadCollectionProcesses();
    };
    
    window.testLoadAPI = function() {
        console.log('Manual test: Loading API status');
        pollForUpdates();
    };
    
    // 初期化 - DOMが完全に読み込まれてから実行
    console.log('Initializing dashboard...');
    
    // DOM要素の存在確認
    const collectionContainer = document.getElementById('collection-processes');
    const apiContainer = document.getElementById('api-status-container');
    
    console.log('Collection container found:', !!collectionContainer);
    console.log('API container found:', !!apiContainer);
    
    if (collectionContainer && apiContainer) {
        // 少し遅延してから実行
        setTimeout(() => {
            console.log('Starting delayed initialization...');
            loadCollectionProcesses(); // 直接呼び出し
            connectWebSocket();
        }, 500);
    } else {
        console.error('Required DOM elements not found');
        setTimeout(() => {
            loadCollectionProcesses();
            connectWebSocket();
        }, 1000);
    }
    
    // タブがアクティブになったときに再接続を試行
    document.addEventListener('visibilitychange', function() {
        if (!document.hidden && (!socket || socket.readyState !== WebSocket.OPEN)) {
            connectWebSocket();
        }
    });
});
</script>
{% endblock %}